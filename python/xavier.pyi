from typing import ClassVar

b8: Dtype
binary_dtypes: dict
device0: Device
f16: Dtype
f32: Dtype
f64: Dtype
i16: Dtype
i32: Dtype
i64: Dtype
i8: Dtype
num_dtypes: set
opnames: dict

class AddOp(BinaryOp):
    def __init__(self, *args, **kwargs) -> None: ...

class ArangeOp(Op):
    def __init__(self, *args, **kwargs) -> None: ...
    def dtype(self) -> Dtype: ...
    def start(self) -> int: ...
    def step(self) -> int: ...
    def view(self) -> list[int]: ...

class Array:
    def __init__(self, shape: Shape, dtype: Dtype = ..., device: Device = ...) -> None: ...
    def alloc(self) -> None: ...
    @staticmethod
    def arange(view: list[int], start: int, step: int, dtype: Dtype = ..., device: Device = ...) -> Array: ...
    @staticmethod
    def constant(view: list[int], c: float, dtype: Dtype = ..., device: Device = ...) -> Array: ...
    def copy_to(self, dest: Array) -> None: ...
    def device(self) -> Device: ...
    def dtype(self) -> Dtype: ...
    @staticmethod
    def from_buffer(buff: Buffer, device: Device = ...) -> Array: ...
    def grad(self) -> Array: ...
    def id(self) -> int: ...
    def interpret_(self, dtype: Dtype) -> Array: ...
    def is_contiguous(self) -> bool: ...
    def nbytes(self) -> int: ...
    def numel(self) -> int: ...
    def op(self, *args, **kwargs): ...
    def ptr(self) -> int: ...
    def reshape_(self, view: list[int]) -> Array: ...
    def shape(self) -> Shape: ...
    def __add__(self, rhs: Array) -> Array: ...
    def __buffer__(self, *args, **kwargs): ...
    def __getitem__(self, obj: object) -> Array: ...
    def __len__(self) -> int: ...
    def __mul__(self, rhs: Array) -> Array: ...
    def __release_buffer__(self, *args, **kwargs): ...
    def __sub__(self, rhs: Array) -> Array: ...
    def __truediv__(self, rhs: Array) -> Array: ...

class BinaryOp(Op):
    def __init__(self, *args, **kwargs) -> None: ...
    def lhs(self) -> Array: ...
    def rhs(self) -> Array: ...

class BroadcastOp(TransformOp):
    def __init__(self, *args, **kwargs) -> None: ...
    def view(self) -> list[int]: ...

class ConstOp(Op):
    def __init__(self, *args, **kwargs) -> None: ...
    def const(self) -> float: ...
    def dtype(self) -> Dtype: ...
    def view(self) -> list[int]: ...

class Device:
    def __init__(self, *args, **kwargs) -> None: ...
    def idx(self) -> int: ...
    def type(self) -> DeviceType: ...
    def __eq__(self, arg0: Device) -> bool: ...
    def __neq__(self, arg0: Device) -> bool: ...

class DeviceType:
    __members__: ClassVar[dict] = ...  # read-only
    CPU: ClassVar[DeviceType] = ...
    MPS: ClassVar[DeviceType] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class DivOp(BinaryOp):
    def __init__(self, *args, **kwargs) -> None: ...

class Dtype:
    def __init__(self, name: str, size: int) -> None: ...
    def name(self) -> str: ...
    def size(self) -> int: ...
    def __eq__(self, dtype: Dtype) -> bool: ...
    def __hash__(self) -> int: ...
    def __neq__(self, dtype: Dtype) -> bool: ...

class ExpOp(UnaryOp):
    def __init__(self, *args, **kwargs) -> None: ...

class Graph:
    def __init__(self, root: Array) -> None: ...
    def backward(self) -> None: ...
    def forward(self) -> None: ...
    def root(self) -> Array: ...

class LogOp(UnaryOp):
    def __init__(self, *args, **kwargs) -> None: ...

class MulOp(BinaryOp):
    def __init__(self, *args, **kwargs) -> None: ...

class NegOp(UnaryOp):
    def __init__(self, *args, **kwargs) -> None: ...

class Op:
    def __init__(self, *args, **kwargs) -> None: ...
    def name(self) -> OpName: ...
    def type(self) -> OpType: ...

class OpName:
    __members__: ClassVar[dict] = ...  # read-only
    ADD: ClassVar[OpName] = ...
    ARANGE: ClassVar[OpName] = ...
    CONSTANT: ClassVar[OpName] = ...
    DIV: ClassVar[OpName] = ...
    EXP: ClassVar[OpName] = ...
    LOG: ClassVar[OpName] = ...
    MATMUL: ClassVar[OpName] = ...
    MUL: ClassVar[OpName] = ...
    NEG: ClassVar[OpName] = ...
    RESHAPE: ClassVar[OpName] = ...
    SUB: ClassVar[OpName] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class OpType:
    __members__: ClassVar[dict] = ...  # read-only
    BINARY: ClassVar[OpType] = ...
    INITIALIZER: ClassVar[OpType] = ...
    TRANSFORM: ClassVar[OpType] = ...
    UNARY: ClassVar[OpType] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class ReshapeOp(TransformOp):
    def __init__(self, *args, **kwargs) -> None: ...
    def view(self) -> list[int]: ...

class Shape:
    def __init__(self, view: list[int]) -> None: ...
    def contiguous_stride(self) -> list[int]: ...
    def elms_per_dim(self) -> list[int]: ...
    def ndim(self) -> int: ...
    def numel(self) -> int: ...
    def offset(self) -> int: ...
    def stride(self) -> list[int]: ...
    def view(self) -> list[int]: ...
    def __eq__(self, shape: Shape) -> bool: ...
    def __getitem__(self, dim: object) -> list[int]: ...
    def __len__(self) -> int: ...
    def __neq__(self, shape: Shape) -> bool: ...

class SliceOp(TransformOp):
    def __init__(self, *args, **kwargs) -> None: ...
    def ranges(self, *args, **kwargs): ...

class SubOp(BinaryOp):
    def __init__(self, *args, **kwargs) -> None: ...

class TransformOp(Op):
    def __init__(self, *args, **kwargs) -> None: ...
    def operand(self) -> Array: ...

class UnaryOp(Op):
    def __init__(self, *args, **kwargs) -> None: ...
    def operand(self) -> Array: ...
