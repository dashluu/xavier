import numpy
from typing import ClassVar

b8: Dtype
device0: Device
f16: Dtype
f32: Dtype
i16: Dtype
i32: Dtype
i8: Dtype

class Array:
    def __init__(self, shape: Shape, dtype: Dtype = ..., device: Device = ...) -> None: ...
    def T(self, start_dim: int = ..., end_dim: int = ...) -> Array: ...
    def access_(self, k: int) -> int: ...
    @staticmethod
    def arange(view: list[int], start: int, step: int, dtype: Dtype = ..., device: Device = ..., constant: bool = ...) -> Array: ...
    def as_contiguous(self) -> Array: ...
    def broadcast(self, view: list[int]) -> Array: ...
    def broadcast_to(self, view: list[int]) -> Array: ...
    def copy(self) -> Array: ...
    def device(self) -> Device: ...
    def dtype(self) -> Dtype: ...
    def exp(self, in_place: bool = ...) -> Array: ...
    def flatten(self, start_dim: int = ..., end_dim: int = ...) -> Array: ...
    @staticmethod
    def from_buffer(buff: Buffer, device: Device = ..., constant: bool = ...) -> Array: ...
    @staticmethod
    def from_numpy(np_arr: numpy.ndarray, device: Device = ..., constant: bool = ...) -> Array: ...
    @staticmethod
    def full(view: list[int], c: object, dtype: Dtype = ..., device: Device = ..., constant: bool = ...) -> Array: ...
    @staticmethod
    def full_like(arr: Array, c: object, device: Device = ..., constant: bool = ...) -> Array: ...
    def id(self) -> int: ...
    def is_contiguous(self) -> bool: ...
    def itemsize(self) -> int: ...
    def log(self, in_place: bool = ...) -> Array: ...
    def nbytes(self) -> int: ...
    def ndim(self) -> int: ...
    def neg(self, in_place: bool = ...) -> Array: ...
    def numel(self) -> int: ...
    def offset(self) -> int: ...
    @staticmethod
    def ones(view: list[int], dtype: Dtype = ..., device: Device = ..., constant: bool = ...) -> Array: ...
    @staticmethod
    def ones_like(arr: Array, device: Device = ..., constant: bool = ...) -> Array: ...
    def permute(self, order: list[int]) -> Array: ...
    def ptr(self) -> int: ...
    def recip(self, in_place: bool = ...) -> Array: ...
    def reshape(self, view: list[int]) -> Array: ...
    def shape(self) -> Shape: ...
    def sq(self, in_place: bool = ...) -> Array: ...
    def sqrt(self, in_place: bool = ...) -> Array: ...
    def stride(self) -> list[int]: ...
    def to_numpy(self) -> numpy.ndarray: ...
    def view(self) -> list[int]: ...
    @staticmethod
    def zeros(view: list[int], dtype: Dtype = ..., device: Device = ..., constant: bool = ...) -> Array: ...
    @staticmethod
    def zeros_like(arr: Array, device: Device = ..., constant: bool = ...) -> Array: ...
    def __add__(self, rhs: Array) -> Array: ...
    def __buffer__(self, *args, **kwargs): ...
    def __eq__(self, rhs: object) -> Array: ...
    def __ge__(self, rhs: object) -> Array: ...
    def __getitem__(self, obj: object) -> Array: ...
    def __gt__(self, rhs: object) -> Array: ...
    def __iadd__(self, rhs: Array) -> Array: ...
    def __imul__(self, rhs: Array) -> Array: ...
    def __isub__(self, rhs: Array) -> Array: ...
    def __itruediv__(self, rhs: Array) -> Array: ...
    def __le__(self, rhs: object) -> Array: ...
    def __len__(self) -> int: ...
    def __lt__(self, rhs: object) -> Array: ...
    def __matmul__(self, rhs: Array) -> Array: ...
    def __mul__(self, rhs: object) -> Array: ...
    def __ne__(self, rhs: object) -> Array: ...
    def __neg__(self) -> Array: ...
    def __release_buffer__(self, *args, **kwargs): ...
    def __rmul__(self, rhs: object) -> Array: ...
    def __sub__(self, rhs: Array) -> Array: ...
    def __truediv__(self, rhs: Array) -> Array: ...
    @property
    def grad(self) -> Array: ...

class Device:
    def __init__(self, *args, **kwargs) -> None: ...
    def idx(self) -> int: ...
    def type(self) -> DeviceType: ...
    def __eq__(self, arg0: Device) -> bool: ...
    def __neq__(self, arg0: Device) -> bool: ...

class DeviceType:
    __members__: ClassVar[dict] = ...  # read-only
    CPU: ClassVar[DeviceType] = ...
    MPS: ClassVar[DeviceType] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Dtype:
    def __init__(self, name: str, size: int) -> None: ...
    def name(self) -> str: ...
    def size(self) -> int: ...
    def __eq__(self, dtype: Dtype) -> bool: ...
    def __hash__(self) -> int: ...
    def __neq__(self, dtype: Dtype) -> bool: ...

class Graph:
    def __init__(self, *args, **kwargs) -> None: ...
    def backward(self) -> None: ...
    def compile(self) -> None: ...
    def forward(self) -> None: ...
    def root(self) -> Array: ...

class MTLContext:
    def __init__(self, lib_path: str) -> None: ...

class MTLGraph(Graph):
    def __init__(self, root: Array, ctx) -> None: ...

class Shape:
    def __init__(self, view: list[int]) -> None: ...
    def broadcast(self, rhs: list[int]) -> Shape: ...
    def broadcast_to(self, target: list[int]) -> Shape: ...
    def broadcastable(self, rhs: list[int]) -> bool: ...
    def broadcastable_to(self, target: list[int]) -> bool: ...
    def contiguous_stride(self) -> list[int]: ...
    def elms_per_dim(self) -> list[int]: ...
    def is_contiguous(self) -> bool: ...
    def matmul_broadcastable(self, rhs: list[int]) -> bool: ...
    def ndim(self) -> int: ...
    def numel(self) -> int: ...
    def offset(self) -> int: ...
    def permute(self, order: list[int]) -> Shape: ...
    def remove(self, dim: int) -> Shape: ...
    def stride(self) -> list[int]: ...
    def view(self) -> list[int]: ...
    def __eq__(self, shape: Shape) -> bool: ...
    def __getitem__(self, dim: object) -> list[int]: ...
    def __len__(self) -> int: ...
    def __neq__(self, shape: Shape) -> bool: ...

def T(arr: Array, start_dim: int = ..., end_dim: int = ...) -> Array: ...
def add(lhs: object, rhs: object) -> Array: ...
def div(lhs: object, rhs: object) -> Array: ...
def eq(lhs: object, rhs: object) -> Array: ...
def exp(arr: object, in_place: bool = ...) -> Array: ...
def flatten(arr: Array, start_dim: int = ..., end_dim: int = ...) -> Array: ...
def geq(lhs: object, rhs: object) -> Array: ...
def gt(lhs: object, rhs: object) -> Array: ...
def leq(lhs: object, rhs: object) -> Array: ...
def log(arr: object, in_place: bool = ...) -> Array: ...
def lt(lhs: object, rhs: object) -> Array: ...
def matmul(lhs: object, rhs: object) -> Array: ...
def mul(lhs: object, rhs: object) -> Array: ...
def neg(arr: object, in_place: bool = ...) -> Array: ...
def neq(lhs: object, rhs: object) -> Array: ...
def permute(arr: Array, order: list[int]) -> Array: ...
def recip(arr: object, in_place: bool = ...) -> Array: ...
def sq(arr: object, in_place: bool = ...) -> Array: ...
def sqrt(arr: object, in_place: bool = ...) -> Array: ...
def sub(lhs: object, rhs: object) -> Array: ...
